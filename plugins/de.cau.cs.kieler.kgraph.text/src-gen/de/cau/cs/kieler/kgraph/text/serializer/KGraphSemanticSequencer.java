/*
 * generated by Xtext 2.9.2
 */
package de.cau.cs.kieler.kgraph.text.serializer;

import com.google.inject.Inject;
import de.cau.cs.kieler.kgraph.text.services.KGraphGrammarAccess;
import de.cau.cs.kieler.klighd.krendering.KAction;
import de.cau.cs.kieler.klighd.krendering.KArc;
import de.cau.cs.kieler.klighd.krendering.KAreaPlacementData;
import de.cau.cs.kieler.klighd.krendering.KBackground;
import de.cau.cs.kieler.klighd.krendering.KBottomPosition;
import de.cau.cs.kieler.klighd.krendering.KChildArea;
import de.cau.cs.kieler.klighd.krendering.KColor;
import de.cau.cs.kieler.klighd.krendering.KCustomRendering;
import de.cau.cs.kieler.klighd.krendering.KDecoratorPlacementData;
import de.cau.cs.kieler.klighd.krendering.KEllipse;
import de.cau.cs.kieler.klighd.krendering.KFontBold;
import de.cau.cs.kieler.klighd.krendering.KFontItalic;
import de.cau.cs.kieler.klighd.krendering.KFontName;
import de.cau.cs.kieler.klighd.krendering.KFontSize;
import de.cau.cs.kieler.klighd.krendering.KForeground;
import de.cau.cs.kieler.klighd.krendering.KGridPlacement;
import de.cau.cs.kieler.klighd.krendering.KGridPlacementData;
import de.cau.cs.kieler.klighd.krendering.KHorizontalAlignment;
import de.cau.cs.kieler.klighd.krendering.KImage;
import de.cau.cs.kieler.klighd.krendering.KInvisibility;
import de.cau.cs.kieler.klighd.krendering.KLeftPosition;
import de.cau.cs.kieler.klighd.krendering.KLineCap;
import de.cau.cs.kieler.klighd.krendering.KLineJoin;
import de.cau.cs.kieler.klighd.krendering.KLineStyle;
import de.cau.cs.kieler.klighd.krendering.KLineWidth;
import de.cau.cs.kieler.klighd.krendering.KPointPlacementData;
import de.cau.cs.kieler.klighd.krendering.KPolygon;
import de.cau.cs.kieler.klighd.krendering.KPolyline;
import de.cau.cs.kieler.klighd.krendering.KPosition;
import de.cau.cs.kieler.klighd.krendering.KRectangle;
import de.cau.cs.kieler.klighd.krendering.KRenderingLibrary;
import de.cau.cs.kieler.klighd.krendering.KRenderingPackage;
import de.cau.cs.kieler.klighd.krendering.KRenderingRef;
import de.cau.cs.kieler.klighd.krendering.KRightPosition;
import de.cau.cs.kieler.klighd.krendering.KRotation;
import de.cau.cs.kieler.klighd.krendering.KRoundedBendsPolyline;
import de.cau.cs.kieler.klighd.krendering.KRoundedRectangle;
import de.cau.cs.kieler.klighd.krendering.KShadow;
import de.cau.cs.kieler.klighd.krendering.KSpline;
import de.cau.cs.kieler.klighd.krendering.KStyleHolder;
import de.cau.cs.kieler.klighd.krendering.KStyleRef;
import de.cau.cs.kieler.klighd.krendering.KText;
import de.cau.cs.kieler.klighd.krendering.KTextUnderline;
import de.cau.cs.kieler.klighd.krendering.KTopPosition;
import de.cau.cs.kieler.klighd.krendering.KVerticalAlignment;
import java.util.Set;
import org.eclipse.elk.core.klayoutdata.KEdgeLayout;
import org.eclipse.elk.core.klayoutdata.KIdentifier;
import org.eclipse.elk.core.klayoutdata.KInsets;
import org.eclipse.elk.core.klayoutdata.KLayoutDataPackage;
import org.eclipse.elk.core.klayoutdata.KPoint;
import org.eclipse.elk.core.klayoutdata.KShapeLayout;
import org.eclipse.elk.graph.KEdge;
import org.eclipse.elk.graph.KGraphPackage;
import org.eclipse.elk.graph.KLabel;
import org.eclipse.elk.graph.KNode;
import org.eclipse.elk.graph.KPort;
import org.eclipse.elk.graph.PersistentEntry;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class KGraphSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KGraphGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KGraphPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KGraphPackage.KEDGE:
				sequence_KEdge(context, (KEdge) semanticObject); 
				return; 
			case KGraphPackage.KLABEL:
				sequence_KLabel(context, (KLabel) semanticObject); 
				return; 
			case KGraphPackage.KNODE:
				if (rule == grammarAccess.getKNodeRule()) {
					sequence_KNode(context, (KNode) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParentKNodeRule()) {
					sequence_ParentKNode(context, (KNode) semanticObject); 
					return; 
				}
				else break;
			case KGraphPackage.KPORT:
				sequence_KPort(context, (KPort) semanticObject); 
				return; 
			case KGraphPackage.PERSISTENT_ENTRY:
				sequence_Property(context, (PersistentEntry) semanticObject); 
				return; 
			}
		else if (epackage == KLayoutDataPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KLayoutDataPackage.KEDGE_LAYOUT:
				if (rule == grammarAccess.getEmptyKEdgeLayoutRule()) {
					sequence_EmptyKEdgeLayout(context, (KEdgeLayout) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKEdgeLayoutRule()) {
					sequence_KEdgeLayout(context, (KEdgeLayout) semanticObject); 
					return; 
				}
				else break;
			case KLayoutDataPackage.KIDENTIFIER:
				sequence_KIdentifier(context, (KIdentifier) semanticObject); 
				return; 
			case KLayoutDataPackage.KINSETS:
				if (rule == grammarAccess.getEmptyKInsetsRule()) {
					sequence_EmptyKInsets(context, (KInsets) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKInsetsRule()) {
					sequence_KInsets(context, (KInsets) semanticObject); 
					return; 
				}
				else break;
			case KLayoutDataPackage.KPOINT:
				if (rule == grammarAccess.getEmptyKPointRule()) {
					sequence_EmptyKPoint(context, (KPoint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKPointRule()) {
					sequence_KPoint(context, (KPoint) semanticObject); 
					return; 
				}
				else break;
			case KLayoutDataPackage.KSHAPE_LAYOUT:
				if (rule == grammarAccess.getEmptyKNodeLayoutRule()) {
					sequence_EmptyKNodeLayout(context, (KShapeLayout) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEmptyKShapeLayoutRule()) {
					sequence_EmptyKShapeLayout(context, (KShapeLayout) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKNodeLayoutRule()) {
					sequence_KNodeLayout(context, (KShapeLayout) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKShapeLayoutRule()) {
					sequence_KShapeLayout(context, (KShapeLayout) semanticObject); 
					return; 
				}
				else break;
			}
		else if (epackage == KRenderingPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KRenderingPackage.KACTION:
				sequence_KAction(context, (KAction) semanticObject); 
				return; 
			case KRenderingPackage.KARC:
				if (rule == grammarAccess.getKArcRule()) {
					sequence_KArc(context, (KArc) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKContainerRenderingRule()) {
					sequence_KArc_KContainerRendering(context, (KArc) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KAREA_PLACEMENT_DATA:
				sequence_KAreaPlacementData(context, (KAreaPlacementData) semanticObject); 
				return; 
			case KRenderingPackage.KBACKGROUND:
				if (rule == grammarAccess.getKBackgroundRule()) {
					sequence_KBackground(context, (KBackground) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKColoringRule()) {
					sequence_KBackground_KColoring(context, (KBackground) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KBackground_KColoring_KStyle(context, (KBackground) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KBOTTOM_POSITION:
				if (rule == grammarAccess.getKBottomPositionRule()) {
					sequence_KBottomPosition(context, (KBottomPosition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKYPositionRule()) {
					sequence_KBottomPosition_KYPosition(context, (KBottomPosition) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KCHILD_AREA:
				if (rule == grammarAccess.getKChildAreaRule()) {
					sequence_KChildArea(context, (KChildArea) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKSimpleRenderingRule()) {
					sequence_KChildArea_KSimpleRendering(context, (KChildArea) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KCOLOR:
				sequence_KColor(context, (KColor) semanticObject); 
				return; 
			case KRenderingPackage.KCUSTOM_RENDERING:
				if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKContainerRenderingRule()) {
					sequence_KContainerRendering_KCustomRendering(context, (KCustomRendering) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKCustomRenderingRule()) {
					sequence_KCustomRendering(context, (KCustomRendering) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KDECORATOR_PLACEMENT_DATA:
				sequence_KDecoratorPlacementData(context, (KDecoratorPlacementData) semanticObject); 
				return; 
			case KRenderingPackage.KELLIPSE:
				if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKContainerRenderingRule()) {
					sequence_KContainerRendering_KEllipse(context, (KEllipse) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKEllipseRule()) {
					sequence_KEllipse(context, (KEllipse) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KFONT_BOLD:
				if (rule == grammarAccess.getKFontBoldRule()) {
					sequence_KFontBold(context, (KFontBold) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KFontBold_KStyle(context, (KFontBold) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KFONT_ITALIC:
				if (rule == grammarAccess.getKFontItalicRule()) {
					sequence_KFontItalic(context, (KFontItalic) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KFontItalic_KStyle(context, (KFontItalic) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KFONT_NAME:
				if (rule == grammarAccess.getKFontNameRule()) {
					sequence_KFontName(context, (KFontName) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KFontName_KStyle(context, (KFontName) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KFONT_SIZE:
				if (rule == grammarAccess.getKFontSizeRule()) {
					sequence_KFontSize(context, (KFontSize) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KFontSize_KStyle(context, (KFontSize) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KFOREGROUND:
				if (rule == grammarAccess.getKColoringRule()) {
					sequence_KColoring_KForeground(context, (KForeground) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KColoring_KForeground_KStyle(context, (KForeground) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKForegroundRule()) {
					sequence_KForeground(context, (KForeground) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KGRID_PLACEMENT:
				sequence_KGridPlacement(context, (KGridPlacement) semanticObject); 
				return; 
			case KRenderingPackage.KGRID_PLACEMENT_DATA:
				sequence_KGridPlacementData(context, (KGridPlacementData) semanticObject); 
				return; 
			case KRenderingPackage.KHORIZONTAL_ALIGNMENT:
				if (rule == grammarAccess.getKHorizontalAlignmentRule()) {
					sequence_KHorizontalAlignment(context, (KHorizontalAlignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KHorizontalAlignment_KStyle(context, (KHorizontalAlignment) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KIMAGE:
				if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKContainerRenderingRule()) {
					sequence_KContainerRendering_KImage(context, (KImage) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKImageRule()) {
					sequence_KImage(context, (KImage) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KINVISIBILITY:
				if (rule == grammarAccess.getKInvisibilityRule()) {
					sequence_KInvisibility(context, (KInvisibility) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KInvisibility_KStyle(context, (KInvisibility) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KLEFT_POSITION:
				if (rule == grammarAccess.getKLeftPositionRule()) {
					sequence_KLeftPosition(context, (KLeftPosition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKXPositionRule()) {
					sequence_KLeftPosition_KXPosition(context, (KLeftPosition) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KLINE_CAP:
				if (rule == grammarAccess.getKLineCapRule()) {
					sequence_KLineCap(context, (KLineCap) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KLineCap_KStyle(context, (KLineCap) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KLINE_JOIN:
				if (rule == grammarAccess.getKLineJoinRule()) {
					sequence_KLineJoin(context, (KLineJoin) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KLineJoin_KStyle(context, (KLineJoin) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KLINE_STYLE:
				if (rule == grammarAccess.getKLineStyleRule()) {
					sequence_KLineStyle(context, (KLineStyle) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KLineStyle_KStyle(context, (KLineStyle) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KLINE_WIDTH:
				if (rule == grammarAccess.getKLineWidthRule()) {
					sequence_KLineWidth(context, (KLineWidth) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KLineWidth_KStyle(context, (KLineWidth) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KPOINT_PLACEMENT_DATA:
				sequence_KPointPlacementData(context, (KPointPlacementData) semanticObject); 
				return; 
			case KRenderingPackage.KPOLYGON:
				if (rule == grammarAccess.getKPolygonRule()) {
					sequence_KPolygon(context, (KPolygon) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKPolylineRule()) {
					sequence_KPolygon_KPolyline(context, (KPolygon) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KPOLYLINE:
				if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKPolylineRule()) {
					sequence_KPolyline_KSimplePolyline(context, (KPolyline) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKSimplePolylineRule()) {
					sequence_KSimplePolyline(context, (KPolyline) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KPOSITION:
				sequence_KPosition(context, (KPosition) semanticObject); 
				return; 
			case KRenderingPackage.KRECTANGLE:
				if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKContainerRenderingRule()) {
					sequence_KContainerRendering_KRectangle(context, (KRectangle) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKRectangleRule()) {
					sequence_KRectangle(context, (KRectangle) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KRENDERING_LIBRARY:
				sequence_KRenderingLibrary(context, (KRenderingLibrary) semanticObject); 
				return; 
			case KRenderingPackage.KRENDERING_REF:
				if (rule == grammarAccess.getKRenderingRefRule()) {
					sequence_KRenderingRef(context, (KRenderingRef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKSimpleRenderingRule()) {
					sequence_KRenderingRef_KSimpleRendering(context, (KRenderingRef) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KRIGHT_POSITION:
				if (rule == grammarAccess.getKRightPositionRule()) {
					sequence_KRightPosition(context, (KRightPosition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKXPositionRule()) {
					sequence_KRightPosition_KXPosition(context, (KRightPosition) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KROTATION:
				if (rule == grammarAccess.getKRotationRule()) {
					sequence_KRotation(context, (KRotation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KRotation_KStyle(context, (KRotation) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KROUNDED_BENDS_POLYLINE:
				if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKPolylineRule()) {
					sequence_KPolyline_KRoundedBendsPolyline(context, (KRoundedBendsPolyline) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKRoundedBendsPolylineRule()) {
					sequence_KRoundedBendsPolyline(context, (KRoundedBendsPolyline) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KROUNDED_RECTANGLE:
				if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKContainerRenderingRule()) {
					sequence_KContainerRendering_KRoundedRectangle(context, (KRoundedRectangle) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKRoundedRectangleRule()) {
					sequence_KRoundedRectangle(context, (KRoundedRectangle) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KSHADOW:
				if (rule == grammarAccess.getKShadowRule()) {
					sequence_KShadow(context, (KShadow) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KShadow_KStyle(context, (KShadow) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KSPLINE:
				if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKPolylineRule()) {
					sequence_KPolyline_KSpline(context, (KSpline) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKSplineRule()) {
					sequence_KSpline(context, (KSpline) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KSTYLE_HOLDER:
				sequence_KStyleHolder(context, (KStyleHolder) semanticObject); 
				return; 
			case KRenderingPackage.KSTYLE_REF:
				if (rule == grammarAccess.getKStyleRefRule()) {
					sequence_KStyleRef(context, (KStyleRef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKStyleRule()) {
					sequence_KStyle_KStyleRef(context, (KStyleRef) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KTEXT:
				if (rule == grammarAccess.getKRenderingRule()
						|| rule == grammarAccess.getKSimpleRenderingRule()) {
					sequence_KSimpleRendering_KText(context, (KText) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKTextRule()) {
					sequence_KText(context, (KText) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KTEXT_UNDERLINE:
				if (rule == grammarAccess.getKStyleRule()) {
					sequence_KStyle_KTextUnderline(context, (KTextUnderline) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKTextUnderlineRule()) {
					sequence_KTextUnderline(context, (KTextUnderline) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KTOP_POSITION:
				if (rule == grammarAccess.getKTopPositionRule()) {
					sequence_KTopPosition(context, (KTopPosition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKYPositionRule()) {
					sequence_KTopPosition_KYPosition(context, (KTopPosition) semanticObject); 
					return; 
				}
				else break;
			case KRenderingPackage.KVERTICAL_ALIGNMENT:
				if (rule == grammarAccess.getKStyleRule()) {
					sequence_KStyle_KVerticalAlignment(context, (KVerticalAlignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKVerticalAlignmentRule()) {
					sequence_KVerticalAlignment(context, (KVerticalAlignment) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EmptyKEdgeLayout returns KEdgeLayout
	 *
	 * Constraint:
	 *     (sourcePoint=EmptyKPoint targetPoint=EmptyKPoint)
	 */
	protected void sequence_EmptyKEdgeLayout(ISerializationContext context, KEdgeLayout semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KLayoutDataPackage.Literals.KEDGE_LAYOUT__SOURCE_POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KLayoutDataPackage.Literals.KEDGE_LAYOUT__SOURCE_POINT));
			if (transientValues.isValueTransient(semanticObject, KLayoutDataPackage.Literals.KEDGE_LAYOUT__TARGET_POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KLayoutDataPackage.Literals.KEDGE_LAYOUT__TARGET_POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmptyKEdgeLayoutAccess().getSourcePointEmptyKPointParserRuleCall_0_0(), semanticObject.getSourcePoint());
		feeder.accept(grammarAccess.getEmptyKEdgeLayoutAccess().getTargetPointEmptyKPointParserRuleCall_1_0(), semanticObject.getTargetPoint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EmptyKInsets returns KInsets
	 *
	 * Constraint:
	 *     {KInsets}
	 */
	protected void sequence_EmptyKInsets(ISerializationContext context, KInsets semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyKNodeLayout returns KShapeLayout
	 *
	 * Constraint:
	 *     insets=EmptyKInsets
	 */
	protected void sequence_EmptyKNodeLayout(ISerializationContext context, KShapeLayout semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KLayoutDataPackage.Literals.KSHAPE_LAYOUT__INSETS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KLayoutDataPackage.Literals.KSHAPE_LAYOUT__INSETS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmptyKNodeLayoutAccess().getInsetsEmptyKInsetsParserRuleCall_0(), semanticObject.getInsets());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EmptyKPoint returns KPoint
	 *
	 * Constraint:
	 *     {KPoint}
	 */
	protected void sequence_EmptyKPoint(ISerializationContext context, KPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyKShapeLayout returns KShapeLayout
	 *
	 * Constraint:
	 *     {KShapeLayout}
	 */
	protected void sequence_EmptyKShapeLayout(ISerializationContext context, KShapeLayout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KAction returns KAction
	 *
	 * Constraint:
	 *     (trigger=Trigger actionId=QualifiedID)
	 */
	protected void sequence_KAction(ISerializationContext context, KAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KRenderingPackage.Literals.KACTION__TRIGGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KRenderingPackage.Literals.KACTION__TRIGGER));
			if (transientValues.isValueTransient(semanticObject, KRenderingPackage.Literals.KACTION__ACTION_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KRenderingPackage.Literals.KACTION__ACTION_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKActionAccess().getTriggerTriggerEnumRuleCall_0_0(), semanticObject.getTrigger());
		feeder.accept(grammarAccess.getKActionAccess().getActionIdQualifiedIDParserRuleCall_2_0(), semanticObject.getActionId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     KArc returns KArc
	 *
	 * Constraint:
	 *     (startAngle=DEGREES arcAngle=DEGREES arcType=Arc?)
	 */
	protected void sequence_KArc(ISerializationContext context, KArc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KArc
	 *     KContainerRendering returns KArc
	 *
	 * Constraint:
	 *     (
	 *         startAngle=DEGREES 
	 *         arcAngle=DEGREES 
	 *         arcType=Arc? 
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         (styles+=KStyle | actions+=KAction | placementData=KPlacementData | childPlacement=KPlacement)* 
	 *         children+=KRendering*
	 *     )
	 */
	protected void sequence_KArc_KContainerRendering(ISerializationContext context, KArc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KPlacementData returns KAreaPlacementData
	 *     KAreaPlacementData returns KAreaPlacementData
	 *
	 * Constraint:
	 *     (topLeft=KPosition | bottomRight=KPosition)*
	 */
	protected void sequence_KAreaPlacementData(ISerializationContext context, KAreaPlacementData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KBackground returns KBackground
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'?)
	 */
	protected void sequence_KBackground(ISerializationContext context, KBackground semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KColoring returns KBackground
	 *
	 * Constraint:
	 *     (
	 *         propagateToChildren?='propagate'? 
	 *         selection?='selection'? 
	 *         (color=KColor alpha=ALPHA? (targetColor=KColor targetAlpha=ALPHA? gradientAngle=Float?)?)?
	 *     )
	 */
	protected void sequence_KBackground_KColoring(ISerializationContext context, KBackground semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KBackground
	 *
	 * Constraint:
	 *     (
	 *         propagateToChildren?='propagate'? 
	 *         selection?='selection'? 
	 *         (color=KColor alpha=ALPHA? (targetColor=KColor targetAlpha=ALPHA? gradientAngle=Float?)?)? 
	 *         modifierId=QualifiedID?
	 *     )
	 */
	protected void sequence_KBackground_KColoring_KStyle(ISerializationContext context, KBackground semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KBottomPosition returns KBottomPosition
	 *
	 * Constraint:
	 *     {KBottomPosition}
	 */
	protected void sequence_KBottomPosition(ISerializationContext context, KBottomPosition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KYPosition returns KBottomPosition
	 *
	 * Constraint:
	 *     (relative=PERCENT | (relative=PERCENT? absolute=Float))?
	 */
	protected void sequence_KBottomPosition_KYPosition(ISerializationContext context, KBottomPosition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KChildArea returns KChildArea
	 *
	 * Constraint:
	 *     {KChildArea}
	 */
	protected void sequence_KChildArea(ISerializationContext context, KChildArea semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KChildArea
	 *     KSimpleRendering returns KChildArea
	 *
	 * Constraint:
	 *     (id=QualifiedID? persistentEntries+=Property* (styles+=KStyle | actions+=KAction | placementData=KPlacementData)*)
	 */
	protected void sequence_KChildArea_KSimpleRendering(ISerializationContext context, KChildArea semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KColor returns KColor
	 *
	 * Constraint:
	 *     ((red=RED green=GREEN? blue=BLUE?) | (green=GREEN blue=BLUE?) | blue=BLUE)
	 */
	protected void sequence_KColor(ISerializationContext context, KColor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KColoring returns KForeground
	 *
	 * Constraint:
	 *     (
	 *         propagateToChildren?='propagate'? 
	 *         selection?='selection'? 
	 *         (color=KColor alpha=ALPHA? (targetColor=KColor targetAlpha=ALPHA? gradientAngle=Float?)?)?
	 *     )
	 */
	protected void sequence_KColoring_KForeground(ISerializationContext context, KForeground semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KForeground
	 *
	 * Constraint:
	 *     (
	 *         propagateToChildren?='propagate'? 
	 *         selection?='selection'? 
	 *         (color=KColor alpha=ALPHA? (targetColor=KColor targetAlpha=ALPHA? gradientAngle=Float?)?)? 
	 *         modifierId=QualifiedID?
	 *     )
	 */
	protected void sequence_KColoring_KForeground_KStyle(ISerializationContext context, KForeground semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KCustomRendering
	 *     KContainerRendering returns KCustomRendering
	 *
	 * Constraint:
	 *     (
	 *         (bundleName=QualifiedID? className=QualifiedID)? 
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         (styles+=KStyle | actions+=KAction | placementData=KPlacementData | childPlacement=KPlacement)* 
	 *         children+=KRendering*
	 *     )
	 */
	protected void sequence_KContainerRendering_KCustomRendering(ISerializationContext context, KCustomRendering semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KEllipse
	 *     KContainerRendering returns KEllipse
	 *
	 * Constraint:
	 *     (
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         (styles+=KStyle | actions+=KAction | placementData=KPlacementData | childPlacement=KPlacement)* 
	 *         children+=KRendering*
	 *     )
	 */
	protected void sequence_KContainerRendering_KEllipse(ISerializationContext context, KEllipse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KImage
	 *     KContainerRendering returns KImage
	 *
	 * Constraint:
	 *     (
	 *         (bundleName=QualifiedID? imagePath=STRING clipShape=KRendering?)? 
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         (styles+=KStyle | actions+=KAction | placementData=KPlacementData | childPlacement=KPlacement)* 
	 *         children+=KRendering*
	 *     )
	 */
	protected void sequence_KContainerRendering_KImage(ISerializationContext context, KImage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KRectangle
	 *     KContainerRendering returns KRectangle
	 *
	 * Constraint:
	 *     (
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         (styles+=KStyle | actions+=KAction | placementData=KPlacementData | childPlacement=KPlacement)* 
	 *         children+=KRendering*
	 *     )
	 */
	protected void sequence_KContainerRendering_KRectangle(ISerializationContext context, KRectangle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KRoundedRectangle
	 *     KContainerRendering returns KRoundedRectangle
	 *
	 * Constraint:
	 *     (
	 *         (cornerWidth=Float cornerHeight=Float)? 
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         (styles+=KStyle | actions+=KAction | placementData=KPlacementData | childPlacement=KPlacement)* 
	 *         children+=KRendering*
	 *     )
	 */
	protected void sequence_KContainerRendering_KRoundedRectangle(ISerializationContext context, KRoundedRectangle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KCustomRendering returns KCustomRendering
	 *
	 * Constraint:
	 *     (bundleName=QualifiedID? className=QualifiedID)?
	 */
	protected void sequence_KCustomRendering(ISerializationContext context, KCustomRendering semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KPlacementData returns KDecoratorPlacementData
	 *     KDecoratorPlacementData returns KDecoratorPlacementData
	 *
	 * Constraint:
	 *     (
	 *         xOffset=Float | 
	 *         yOffset=Float | 
	 *         width=Float | 
	 *         height=Float | 
	 *         relative=Float | 
	 *         absolute=Float | 
	 *         rotateWithLine=BOOLEAN
	 *     )*
	 */
	protected void sequence_KDecoratorPlacementData(ISerializationContext context, KDecoratorPlacementData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KEdgeLayout returns KEdgeLayout
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (sourcePoint=KPoint ((bendPoints+=KPoint* targetPoint=KPoint) | targetPoint=EmptyKPoint)) | 
	 *             (sourcePoint=EmptyKPoint targetPoint=EmptyKPoint) | 
	 *             (sourcePoint=EmptyKPoint targetPoint=EmptyKPoint)
	 *         ) 
	 *         persistentEntries+=Property*
	 *     )
	 */
	protected void sequence_KEdgeLayout(ISerializationContext context, KEdgeLayout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KEdge returns KEdge
	 *
	 * Constraint:
	 *     (
	 *         data+=KIdentifier? 
	 *         sourcePort=[KPort|QualifiedID]? 
	 *         target=[KNode|QualifiedID] 
	 *         targetPort=[KPort|QualifiedID]? 
	 *         ((data+=KEdgeLayout (labels+=KLabel | data+=KRendering)*) | data+=EmptyKEdgeLayout)
	 *     )
	 */
	protected void sequence_KEdge(ISerializationContext context, KEdge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KEllipse returns KEllipse
	 *
	 * Constraint:
	 *     {KEllipse}
	 */
	protected void sequence_KEllipse(ISerializationContext context, KEllipse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KFontBold returns KFontBold
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? bold=BOOLEAN)
	 */
	protected void sequence_KFontBold(ISerializationContext context, KFontBold semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KFontBold
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? bold=BOOLEAN modifierId=QualifiedID?)
	 */
	protected void sequence_KFontBold_KStyle(ISerializationContext context, KFontBold semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KFontItalic returns KFontItalic
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? italic=BOOLEAN)
	 */
	protected void sequence_KFontItalic(ISerializationContext context, KFontItalic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KFontItalic
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? italic=BOOLEAN modifierId=QualifiedID?)
	 */
	protected void sequence_KFontItalic_KStyle(ISerializationContext context, KFontItalic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KFontName returns KFontName
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? name=STRING)
	 */
	protected void sequence_KFontName(ISerializationContext context, KFontName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KFontName
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? name=STRING modifierId=QualifiedID?)
	 */
	protected void sequence_KFontName_KStyle(ISerializationContext context, KFontName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KFontSize returns KFontSize
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? scaleWithZoom?='scale'? size=FSIZE)
	 */
	protected void sequence_KFontSize(ISerializationContext context, KFontSize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KFontSize
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? scaleWithZoom?='scale'? size=FSIZE modifierId=QualifiedID?)
	 */
	protected void sequence_KFontSize_KStyle(ISerializationContext context, KFontSize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KForeground returns KForeground
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'?)
	 */
	protected void sequence_KForeground(ISerializationContext context, KForeground semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KPlacementData returns KGridPlacementData
	 *     KGridPlacementData returns KGridPlacementData
	 *
	 * Constraint:
	 *     (
	 *         topLeft=KPosition | 
	 *         bottomRight=KPosition | 
	 *         minCellWidth=Float | 
	 *         minCellHeight=Float | 
	 *         flexibleWidth=BOOLEAN | 
	 *         flexibleHeight=BOOLEAN
	 *     )*
	 */
	protected void sequence_KGridPlacementData(ISerializationContext context, KGridPlacementData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KPlacement returns KGridPlacement
	 *     KGridPlacement returns KGridPlacement
	 *
	 * Constraint:
	 *     (topLeft=KPosition | bottomRight=KPosition | numColumns=NATURAL)*
	 */
	protected void sequence_KGridPlacement(ISerializationContext context, KGridPlacement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KHorizontalAlignment returns KHorizontalAlignment
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? horizontalAlignment=HorizontalAlignment)
	 */
	protected void sequence_KHorizontalAlignment(ISerializationContext context, KHorizontalAlignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KHorizontalAlignment
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? horizontalAlignment=HorizontalAlignment modifierId=QualifiedID?)
	 */
	protected void sequence_KHorizontalAlignment_KStyle(ISerializationContext context, KHorizontalAlignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KIdentifier returns KIdentifier
	 *
	 * Constraint:
	 *     (id=QualifiedID persistentEntries+=Property*)
	 */
	protected void sequence_KIdentifier(ISerializationContext context, KIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KImage returns KImage
	 *
	 * Constraint:
	 *     (bundleName=QualifiedID? imagePath=STRING clipShape=KRendering?)?
	 */
	protected void sequence_KImage(ISerializationContext context, KImage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KInsets returns KInsets
	 *
	 * Constraint:
	 *     (top=Float | bottom=Float | left=Float | right=Float)*
	 */
	protected void sequence_KInsets(ISerializationContext context, KInsets semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KInvisibility returns KInvisibility
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? invisible=BOOLEAN)
	 */
	protected void sequence_KInvisibility(ISerializationContext context, KInvisibility semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KInvisibility
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? invisible=BOOLEAN modifierId=QualifiedID?)
	 */
	protected void sequence_KInvisibility_KStyle(ISerializationContext context, KInvisibility semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KLabel returns KLabel
	 *
	 * Constraint:
	 *     (data+=KIdentifier? text=STRING? ((data+=KShapeLayout data+=KRendering*) | data+=EmptyKShapeLayout))
	 */
	protected void sequence_KLabel(ISerializationContext context, KLabel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KLeftPosition returns KLeftPosition
	 *
	 * Constraint:
	 *     {KLeftPosition}
	 */
	protected void sequence_KLeftPosition(ISerializationContext context, KLeftPosition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KXPosition returns KLeftPosition
	 *
	 * Constraint:
	 *     (relative=PERCENT | (relative=PERCENT? absolute=Float))?
	 */
	protected void sequence_KLeftPosition_KXPosition(ISerializationContext context, KLeftPosition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KLineCap returns KLineCap
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? lineCap=LineCap)
	 */
	protected void sequence_KLineCap(ISerializationContext context, KLineCap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KLineCap
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? lineCap=LineCap modifierId=QualifiedID?)
	 */
	protected void sequence_KLineCap_KStyle(ISerializationContext context, KLineCap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KLineJoin returns KLineJoin
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? lineJoin=LineJoin)
	 */
	protected void sequence_KLineJoin(ISerializationContext context, KLineJoin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KLineJoin
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? lineJoin=LineJoin modifierId=QualifiedID?)
	 */
	protected void sequence_KLineJoin_KStyle(ISerializationContext context, KLineJoin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KLineStyle returns KLineStyle
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? lineStyle=LineStyle dashOffset=Float? dashPattern+=Float*)
	 */
	protected void sequence_KLineStyle(ISerializationContext context, KLineStyle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KLineStyle
	 *
	 * Constraint:
	 *     (
	 *         propagateToChildren?='propagate'? 
	 *         selection?='selection'? 
	 *         lineStyle=LineStyle 
	 *         dashOffset=Float? 
	 *         dashPattern+=Float* 
	 *         modifierId=QualifiedID?
	 *     )
	 */
	protected void sequence_KLineStyle_KStyle(ISerializationContext context, KLineStyle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KLineWidth returns KLineWidth
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? lineWidth=Float)
	 */
	protected void sequence_KLineWidth(ISerializationContext context, KLineWidth semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KLineWidth
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? lineWidth=Float modifierId=QualifiedID?)
	 */
	protected void sequence_KLineWidth_KStyle(ISerializationContext context, KLineWidth semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KNodeLayout returns KShapeLayout
	 *
	 * Constraint:
	 *     (xpos=Float? ((ypos=Float | width=Float | height=Float | persistentEntries+=Property)? xpos=Float?)* (insets=KInsets | insets=EmptyKInsets))
	 */
	protected void sequence_KNodeLayout(ISerializationContext context, KShapeLayout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KNode returns KNode
	 *
	 * Constraint:
	 *     (
	 *         data+=KIdentifier? 
	 *         (
	 *             (
	 *                 data+=KNodeLayout 
	 *                 (
	 *                     labels+=KLabel | 
	 *                     children+=KNode | 
	 *                     ports+=KPort | 
	 *                     outgoingEdges+=KEdge | 
	 *                     data+=KRendering | 
	 *                     data+=KRenderingLibrary
	 *                 )*
	 *             ) | 
	 *             data+=EmptyKNodeLayout
	 *         )
	 *     )
	 */
	protected void sequence_KNode(ISerializationContext context, KNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KPlacementData returns KPointPlacementData
	 *     KPointPlacementData returns KPointPlacementData
	 *
	 * Constraint:
	 *     (
	 *         referencePoint=KPosition | 
	 *         minWidth=Float | 
	 *         minHeight=Float | 
	 *         horizontalAlignment=HorizontalAlignment | 
	 *         verticalAlignment=VerticalAlignment | 
	 *         horizontalMargin=Float | 
	 *         verticalMargin=Float
	 *     )*
	 */
	protected void sequence_KPointPlacementData(ISerializationContext context, KPointPlacementData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KPoint returns KPoint
	 *
	 * Constraint:
	 *     (x=Float y=Float)
	 */
	protected void sequence_KPoint(ISerializationContext context, KPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KLayoutDataPackage.Literals.KPOINT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KLayoutDataPackage.Literals.KPOINT__X));
			if (transientValues.isValueTransient(semanticObject, KLayoutDataPackage.Literals.KPOINT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KLayoutDataPackage.Literals.KPOINT__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKPointAccess().getXFloatParserRuleCall_0_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getKPointAccess().getYFloatParserRuleCall_2_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     KPolygon returns KPolygon
	 *
	 * Constraint:
	 *     {KPolygon}
	 */
	protected void sequence_KPolygon(ISerializationContext context, KPolygon semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KPolygon
	 *     KPolyline returns KPolygon
	 *
	 * Constraint:
	 *     (
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         ((styles+=KStyle | actions+=KAction | placementData=KPlacementData | childPlacement=KPlacement)? (points+=KPosition points+=KPosition*)?)+ 
	 *         junctionPointRendering=KRendering? 
	 *         children+=KRendering*
	 *     )
	 */
	protected void sequence_KPolygon_KPolyline(ISerializationContext context, KPolygon semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KRoundedBendsPolyline
	 *     KPolyline returns KRoundedBendsPolyline
	 *
	 * Constraint:
	 *     (
	 *         bendRadius=Float? 
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         ((styles+=KStyle | actions+=KAction | placementData=KPlacementData | childPlacement=KPlacement)? (points+=KPosition points+=KPosition*)?)+ 
	 *         junctionPointRendering=KRendering? 
	 *         children+=KRendering*
	 *     )
	 */
	protected void sequence_KPolyline_KRoundedBendsPolyline(ISerializationContext context, KRoundedBendsPolyline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KPolyline
	 *     KPolyline returns KPolyline
	 *
	 * Constraint:
	 *     (
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         ((styles+=KStyle | actions+=KAction | placementData=KPlacementData | childPlacement=KPlacement)? (points+=KPosition points+=KPosition*)?)+ 
	 *         junctionPointRendering=KRendering? 
	 *         children+=KRendering*
	 *     )
	 */
	protected void sequence_KPolyline_KSimplePolyline(ISerializationContext context, KPolyline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KSpline
	 *     KPolyline returns KSpline
	 *
	 * Constraint:
	 *     (
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         ((styles+=KStyle | actions+=KAction | placementData=KPlacementData | childPlacement=KPlacement)? (points+=KPosition points+=KPosition*)?)+ 
	 *         junctionPointRendering=KRendering? 
	 *         children+=KRendering*
	 *     )
	 */
	protected void sequence_KPolyline_KSpline(ISerializationContext context, KSpline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KPort returns KPort
	 *
	 * Constraint:
	 *     (data+=KIdentifier? ((data+=KShapeLayout (labels+=KLabel | data+=KRendering)*) | data+=EmptyKShapeLayout))
	 */
	protected void sequence_KPort(ISerializationContext context, KPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KPosition returns KPosition
	 *
	 * Constraint:
	 *     (x=KXPosition y=KYPosition)
	 */
	protected void sequence_KPosition(ISerializationContext context, KPosition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KRenderingPackage.Literals.KPOSITION__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KRenderingPackage.Literals.KPOSITION__X));
			if (transientValues.isValueTransient(semanticObject, KRenderingPackage.Literals.KPOSITION__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KRenderingPackage.Literals.KPOSITION__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKPositionAccess().getXKXPositionParserRuleCall_0_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getKPositionAccess().getYKYPositionParserRuleCall_2_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     KRectangle returns KRectangle
	 *
	 * Constraint:
	 *     {KRectangle}
	 */
	protected void sequence_KRectangle(ISerializationContext context, KRectangle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRenderingLibrary returns KRenderingLibrary
	 *
	 * Constraint:
	 *     (persistentEntries+=Property* (renderings+=KRendering | renderings+=KStyleHolder)*)
	 */
	protected void sequence_KRenderingLibrary(ISerializationContext context, KRenderingLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRenderingRef returns KRenderingRef
	 *
	 * Constraint:
	 *     rendering=[KRendering|QualifiedID]
	 */
	protected void sequence_KRenderingRef(ISerializationContext context, KRenderingRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KRenderingPackage.Literals.KRENDERING_REF__RENDERING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KRenderingPackage.Literals.KRENDERING_REF__RENDERING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKRenderingRefAccess().getRenderingKRenderingQualifiedIDParserRuleCall_2_0_1(), semanticObject.getRendering());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KRenderingRef
	 *     KSimpleRendering returns KRenderingRef
	 *
	 * Constraint:
	 *     (
	 *         rendering=[KRendering|QualifiedID] 
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         (styles+=KStyle | actions+=KAction | placementData=KPlacementData)*
	 *     )
	 */
	protected void sequence_KRenderingRef_KSimpleRendering(ISerializationContext context, KRenderingRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRightPosition returns KRightPosition
	 *
	 * Constraint:
	 *     {KRightPosition}
	 */
	protected void sequence_KRightPosition(ISerializationContext context, KRightPosition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KXPosition returns KRightPosition
	 *
	 * Constraint:
	 *     (relative=PERCENT | (relative=PERCENT? absolute=Float))?
	 */
	protected void sequence_KRightPosition_KXPosition(ISerializationContext context, KRightPosition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRotation returns KRotation
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? rotation=Float rotationAnchor=KPosition?)
	 */
	protected void sequence_KRotation(ISerializationContext context, KRotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KRotation
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? rotation=Float rotationAnchor=KPosition? modifierId=QualifiedID?)
	 */
	protected void sequence_KRotation_KStyle(ISerializationContext context, KRotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRoundedBendsPolyline returns KRoundedBendsPolyline
	 *
	 * Constraint:
	 *     bendRadius=Float?
	 */
	protected void sequence_KRoundedBendsPolyline(ISerializationContext context, KRoundedBendsPolyline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRoundedRectangle returns KRoundedRectangle
	 *
	 * Constraint:
	 *     (cornerWidth=Float cornerHeight=Float)?
	 */
	protected void sequence_KRoundedRectangle(ISerializationContext context, KRoundedRectangle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KShadow returns KShadow
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? color=KColor? (xOffset=Float yOffset=Float blur=Float?)?)
	 */
	protected void sequence_KShadow(ISerializationContext context, KShadow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KShadow
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? color=KColor? (xOffset=Float yOffset=Float blur=Float?)? modifierId=QualifiedID?)
	 */
	protected void sequence_KShadow_KStyle(ISerializationContext context, KShadow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KShapeLayout returns KShapeLayout
	 *
	 * Constraint:
	 *     (xpos=Float | ypos=Float | width=Float | height=Float | persistentEntries+=Property)*
	 */
	protected void sequence_KShapeLayout(ISerializationContext context, KShapeLayout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KSimplePolyline returns KPolyline
	 *
	 * Constraint:
	 *     {KPolyline}
	 */
	protected void sequence_KSimplePolyline(ISerializationContext context, KPolyline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KRendering returns KText
	 *     KSimpleRendering returns KText
	 *
	 * Constraint:
	 *     (
	 *         (text=STRING cursorSelectable=BOOLEAN?)? 
	 *         id=QualifiedID? 
	 *         persistentEntries+=Property* 
	 *         (styles+=KStyle | actions+=KAction | placementData=KPlacementData)*
	 *     )
	 */
	protected void sequence_KSimpleRendering_KText(ISerializationContext context, KText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KSpline returns KSpline
	 *
	 * Constraint:
	 *     {KSpline}
	 */
	protected void sequence_KSpline(ISerializationContext context, KSpline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyleHolder returns KStyleHolder
	 *
	 * Constraint:
	 *     (id=QualifiedID? styles+=KStyle*)
	 */
	protected void sequence_KStyleHolder(ISerializationContext context, KStyleHolder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyleRef returns KStyleRef
	 *
	 * Constraint:
	 *     (selection?='selection'? styleHolder=[KStyleHolder|QualifiedID])
	 */
	protected void sequence_KStyleRef(ISerializationContext context, KStyleRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KStyleRef
	 *
	 * Constraint:
	 *     (selection?='selection'? styleHolder=[KStyleHolder|QualifiedID] modifierId=QualifiedID?)
	 */
	protected void sequence_KStyle_KStyleRef(ISerializationContext context, KStyleRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KTextUnderline
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? underline=Underline modifierId=QualifiedID?)
	 */
	protected void sequence_KStyle_KTextUnderline(ISerializationContext context, KTextUnderline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KStyle returns KVerticalAlignment
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? verticalAlignment=VerticalAlignment modifierId=QualifiedID?)
	 */
	protected void sequence_KStyle_KVerticalAlignment(ISerializationContext context, KVerticalAlignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KTextUnderline returns KTextUnderline
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? underline=Underline)
	 */
	protected void sequence_KTextUnderline(ISerializationContext context, KTextUnderline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KText returns KText
	 *
	 * Constraint:
	 *     (text=STRING cursorSelectable=BOOLEAN?)?
	 */
	protected void sequence_KText(ISerializationContext context, KText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KTopPosition returns KTopPosition
	 *
	 * Constraint:
	 *     {KTopPosition}
	 */
	protected void sequence_KTopPosition(ISerializationContext context, KTopPosition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KYPosition returns KTopPosition
	 *
	 * Constraint:
	 *     (relative=PERCENT | (relative=PERCENT? absolute=Float))?
	 */
	protected void sequence_KTopPosition_KYPosition(ISerializationContext context, KTopPosition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KVerticalAlignment returns KVerticalAlignment
	 *
	 * Constraint:
	 *     (propagateToChildren?='propagate'? selection?='selection'? verticalAlignment=VerticalAlignment)
	 */
	protected void sequence_KVerticalAlignment(ISerializationContext context, KVerticalAlignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParentKNode returns KNode
	 *
	 * Constraint:
	 *     (
	 *         data+=KIdentifier? 
	 *         data+=KNodeLayout 
	 *         (
	 *             labels+=KLabel | 
	 *             children+=KNode | 
	 *             ports+=KPort | 
	 *             outgoingEdges+=KEdge | 
	 *             data+=KRendering | 
	 *             data+=KRenderingLibrary
	 *         )*
	 *     )
	 */
	protected void sequence_ParentKNode(ISerializationContext context, KNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns PersistentEntry
	 *
	 * Constraint:
	 *     (key=QualifiedID value=PropertyValue)
	 */
	protected void sequence_Property(ISerializationContext context, PersistentEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KGraphPackage.Literals.PERSISTENT_ENTRY__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KGraphPackage.Literals.PERSISTENT_ENTRY__KEY));
			if (transientValues.isValueTransient(semanticObject, KGraphPackage.Literals.PERSISTENT_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KGraphPackage.Literals.PERSISTENT_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyAccess().getKeyQualifiedIDParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getPropertyAccess().getValuePropertyValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
